# 科室筛选功能问题排查指南

## 🔍 问题诊断步骤

### 1. 检查前端请求参数

打开浏览器开发者工具（F12），查看Network标签：

1. **检查请求URL**：
   - 应该看到：`GET /doctor/findDoctorBySectionPage?pageNumber=1&size=10&query=&arrangeDate=&dSection=内科`
   - 确认 `dSection` 参数是否正确传递

2. **检查响应数据**：
   - 查看响应状态码（应该是200）
   - 查看响应体中的 `status` 字段（应该是200）
   - 查看 `data.doctors` 数组是否有数据
   - 查看 `data.total` 总数

### 2. 检查后端日志

查看后端控制台日志，应该看到：
```
查询科室医生 - 科室: [内科], 页码: 1, 每页: 10, 医生名: [], 排班日期: []
查询到 X 条记录，总记录数: X
查询结果 - 总数: X, 当前页数据量: X
```

### 3. 检查数据库数据

执行以下SQL检查数据库中是否有对应科室的医生：

```sql
-- 检查某个科室的医生数量
SELECT COUNT(*) FROM doctor_user WHERE d_section = '内科' AND d_state = 1;

-- 查看所有科室及其医生数量
SELECT d_section, COUNT(*) as doctor_count 
FROM doctor_user 
WHERE d_state = 1 
GROUP BY d_section;

-- 查看具体某个科室的医生列表
SELECT d_id, d_name, d_section, d_state 
FROM doctor_user 
WHERE d_section = '内科' AND d_state = 1;
```

### 4. 常见问题及解决方案

#### 问题1：科室名称不匹配
**症状**：请求成功但返回空列表

**原因**：前端传递的科室名称与数据库中的不完全一致

**解决方案**：
- 检查数据库中实际的科室名称
- 确保前端 `sections` 数组中的名称与数据库一致
- 或者修改查询逻辑使用模糊匹配

#### 问题2：没有在职医生
**症状**：数据库有医生但查询不到

**原因**：医生的 `d_state` 不是1（不在职）

**解决方案**：
- 检查医生的 `d_state` 字段
- 确保查询条件正确：`.eq(Doctor::getDState, 1)`

#### 问题3：参数传递问题
**症状**：请求失败或参数错误

**原因**：前端参数名或后端接收参数名不匹配

**解决方案**：
- 确认前端传递的是 `dSection`
- 确认后端接收的是 `@RequestParam(value = "dSection")`

## 🛠️ 临时调试方案

### 方案1：添加调试接口

在后端添加一个调试接口，查看所有科室和医生：

```java
@RequestMapping("debug/allSections")
public R<Map<String, Object>> debugAllSections() {
    // 查询所有科室及其医生数量
    List<Doctor> allDoctors = doctorUserService.list(
        Wrappers.<Doctor>lambdaQuery().eq(Doctor::getDState, 1)
    );
    
    Map<String, Long> sectionCount = allDoctors.stream()
        .collect(Collectors.groupingBy(
            Doctor::getDSection, 
            Collectors.counting()
        ));
    
    Map<String, Object> result = new HashMap<>();
    result.put("sections", sectionCount);
    result.put("totalDoctors", allDoctors.size());
    
    return R.ok(result);
}
```

### 方案2：修改查询逻辑使用模糊匹配

如果科室名称不完全匹配，可以修改查询逻辑：

```java
// 使用模糊匹配
.like(Doctor::getDSection, dSection)
```

### 方案3：前端显示实际返回的数据

在前端添加调试信息显示：

```javascript
.then((res) => {
    console.log("完整响应:", res);
    console.log("响应状态:", res.data.status);
    console.log("响应数据:", res.data.data);
    console.log("医生列表:", res.data.data?.doctors);
    console.log("总数:", res.data.data?.total);
    // ... 其他代码
})
```

## 📝 修复后的代码要点

1. ✅ 后端查询条件已修复：`.eq(Doctor::getDSection, dSection)`
2. ✅ 添加了日志输出，便于调试
3. ✅ 前端添加了加载状态和空数据提示
4. ✅ 前端添加了详细的错误处理和调试日志

## 🚀 下一步操作

1. **运行系统并打开浏览器控制台**
2. **点击不同的科室标签**
3. **查看控制台日志和Network请求**
4. **根据日志信息定位具体问题**

如果问题仍然存在，请提供：
- 浏览器控制台的错误信息
- Network请求的详细信息（URL、参数、响应）
- 后端控制台的日志输出

